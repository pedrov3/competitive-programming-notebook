# competitive-programming-notebook

- [X] Diminuir o tamanho do código do [Aho-corasick](aho-corasick.cpp)
- [ ] substituir begin(), end() para all()
- [ ] substituir vector<int> para vi
- [ ] Melhorar comentários na [bit2d](bit2d.cpp)
- [ ] Juntar [combinatoria.cpp](combinatoria.cpp), [composicao.cpp](composicao.cpp) e [binomio.cpp](binomio.cpp) ?
- [ ] Melhorar comentários do codigo de [conectividade dinâmica](conectividade-dinamica.cpp)
- [ ] Simplificar codigo do [convexhull](convex-hull.cpp)
- [ ] Arrumar código de [euclides estendido](euclides-estendido.cpp)
- [ ] Encontrar um codigo de fluxo máximo melhor
- [ ] Código de fft está muito grande
- [ ] Simplificar código do [Hash generalizado](hash-generalizado.cpp)
- [ ] Simplificar código da [HLD](hld.cpp)
- [ ] Código do [hungáro](hungarian.cpp) está faraônico
- [ ] Encontrar um codigo de interpolação melhor
- [ ] Simplificar código do [kosaraju](kosaraju.cpp)
- [ ] Simplificar código da [LIS](lis.cpp)
- [ ] Simplificar código da [MergeSort Tree](mergesort_tree.cpp)
- [ ] Simplificar código da [NTT](ntt.cpp)
- [ ] Encontrar um código mais simples para Suffix Array O(n)
- [ ] Melhorar comentário [prefixsum2d](prefix_sum2d.cpp)
- [ ] Simplificar código de [scc](scc.cpp)
- [ ] Simplificar código [segment tree dinâmica com lazy](segment_tree_din_lazy.cpp)
- [ ] Procurar implementações de árvore de segmentos persistente
- [ ] Procurar um código mais simples para fluxo máximo de custo mínimo
- [ ] Comentar código de [square root em árvore](sqrt-decomposition-on-trees.cpp)
- [ ] Simplificar código da [trie de bits](trie-bits.cpp)

- [ ] Interval Tree
- [ ] LiChao Tree
- [ ] 2-SAT
- [ ] Eliminação de Gauss
- [ ] Totiente de Euler
- [ ] Teorema Chinês do Resto
- [ ] mover a pasta 'teoria' para o blog?
